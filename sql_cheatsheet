THIS IS A PERSONAL CHEATSHEET FOR SQL, MOSTLY FOCUSED ON SQL COMMANDS AND POSTGRESQL DMBS CONFIGURATION.
IT MIGHT NOT BE THE BEST FOR YOU BECAUSE THIS IS CUSTOM-WRITTEN BY MYSELF, FOR MYSELF. BUT I HOPE IT COMES HANDY
FOR ANYONE READING THIS. I WAS STUDYING THIS CRASH COURSE ON POSTGRESQL FROM feeCodeCamp.org WHILE MAKING THIS SHEET:
https://www.youtube.com/watch?v=qw--VYLpxG4


SQL COMMANDS:

CREATE DATABASE <db-name> = creating a database

DROP DATABASE <db-name> = deleting a database

CREATE TABLE table_name (
        row_name + data_type + constraints_if_any
) ;

Important constraints = NOT NULL, PRIMARY KEY, UNIQUE, FOREIGN KEY

DROP TABLE <table_name> = delete a table

SELECT * FROM <table_name> = view all columns of a table


SELECT <column1>, <column2> FROM <table_name> -> view column(s) of a table

SELECT * FROM <table_name> ORDER BY <column1>, <column2> ASC / DESC -> view a table with ascending or descending order of one or a number of columns

SELECT DISTINCT <column> FROM <table> -> receive an output with duplicate records only shown once for each

WHERE -> It's used to filter data based on custom conditions. Also 'AND' is used for combining 2 or more conditions. ex:
SELECT <column> FROM <table_name> WHERE <condition, ex: gender = 'Male' AND country = 'Iran'> ;

SELECT * FROM <table_name> LIMIT <n> -> "LIMIT" is used to limit the number of records in the output.

SELECT * FROM <table_name> OFFSET <n> LIMIT <m> -> 'OFFSET' is used to declare the starting point (default is 0). For example when we want 11th to 25th record from out table to be shown (skip the first 10 and give me the next 15):

SELECT * FROM <table_name> OFFSET 10 LIMIT 15 ;

another way to declare this:
SELECT * FROM <table_name> OFFSET 10 FIRST 15 ROW ONLY ;


SELECT * FROM person WHERE country IN ('Iran', 'China', 'USA') ;
this can be used when a row record should be a part of a defined set


Also when we need our records to be in a RANGE, we'd go like this:
SELECT * FROM person WHERE date_of_birth BETWEEN DATE '2000-01-01' AND '2016-01-01'
Notice how we put date_of_birth inside cotations and declared that it's a DATE data type.

LIKE: like is used to match values against a pattern using wild cards. for example for finding all records that 'x' exists in the value:

SELECT * FROM <table> WHERE <column> LIKE '%x%' ;

also, the underscore _  displays a variable character. when we want to receive all records that has 3 chars before 'x':

SELECT * FROM <table> WHERE <column> LIKE '%___x%'

in order to let SQL forget about case-sensitivity in our input, we can use 'ILIKE' keyword :
SELECT * FROM <table> WHERE <column> ILIKE '%___X%'

to insert a record to a table:
INSERT INTO <table_name> (column1, column2, ...) VALUES (value1, value2, ...);



GROUP BY:
allows us to group data based on a column.
fof example, let's say we want to know how many people are there in each coutnry?
SELECT <country> COUNT(*) FROM <table> GROUP BY <country>

GROUP BY HAVING:
having an extra filtering after the aggregation.
i.e. in the example above, let's say we want to know how many people are there in each coutnry,
but ONLY for countries with more then 5 people in our table:

SELECT <country> COUNT(*) FROM <table> GROUP BY <country> HAVING COUNT(*) > 5







POSTGRESQL COMMANDS:

psql <db_name> -> open psql CLI to work on a defined database

\i <file_path> -> run commands from a file

AGGREGATE FUNCTION:
these are function that run a calculation on a set of values and return a single value in result

MAX/MIN/AVG(column): find the max/min/average value among all records in a column:
SELECT MAX/MIN/AVG(price) FROM car;

ROUND(value, DecimalPoints): round a value to the closest string, decimal points are optioanl:
SELECT ROUND(AVG(price, 2)) FROM car;

SUM(value): calculate sum of all records in a set:
SELECT SUM(price) FROM car;
SELECT make, SUM(price) FROM car GROUP BY make;

ARITHMETICS:
SQL allows you to do mathematical arithmetics using operators suchas + - * / ^ ! mod

I.E: return actual price of each car in a table with another price with 10 percent discount:
SELECT price, ROUND(price - (price / 10), 1) FROM car 

ALIAS:
by default, when you don't specify a column name for a calcualted value, PG will use the actual
FUNCTION NAME as the column name. We can use ALIAS to provide a custom name for our column. the keyword used here is AS :
SELECT price, ROUND(price - (price / 10), 1) AS discount_price FROM car;

COALESCE:
while working with nulls in PG, COALESCE is useful. It can actually assign a defined value to a null.
let's say we want to tell PG to assign email of "Email not found" for any person record without an email: 
SELECT COALESCE(email, 'Email not found ') FROM PERSON;


TIMEZONE:
NOW() funcion tells us the current time and date.

for returning time only: SELECT NOW()::TIME;
for returning date only: SELECT NOW()::DATE;

to convert a described time to SQL formatted time, just use INTERVAL keyword.
ex: returning date 10 months before now:
SELECT NOW()::DATE - INTERVAL '10 MONTHS'

to extract a field from a date-time : use EXTRACT keyword
SELECT EXTRACT(YEAR FROM NOW()) ;

to calculate age form birth date (calcuate differnece between 2 date-times): use AGE keyword:
SELECT AGE(NOW(),date_or_birth) AS age FROM person;


Coalesce function in SQL takes a list of arguments and returns
the first element of the list that is not null.

to receive them :
SELECT COALESCE(column1, column2) FROM <table>;

to replace a null variable with something else:
SELECT COALESCE(column1, 'value') FROM <table>; 
